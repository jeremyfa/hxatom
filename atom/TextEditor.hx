package atom;
@:native("TextEditor") extern class TextEditor {
	function onDidChangeTitle(callback:haxe.Constraints.Function):atom.Disposable;
	function onDidChangePath(callback:haxe.Constraints.Function):atom.Disposable;
	function onDidChange(callback:haxe.Constraints.Function):atom.Disposable;
	function onDidStopChanging(callback:haxe.Constraints.Function):atom.Disposable;
	function onDidChangeCursorPosition(callback:haxe.Constraints.Function):atom.Disposable;
	function onDidChangeSelectionRange(callback:haxe.Constraints.Function):atom.Disposable;
	function onDidChangeSoftWrapped(callback:haxe.Constraints.Function):atom.Disposable;
	function onDidChangeEncoding(callback:haxe.Constraints.Function):atom.Disposable;
	function observeGrammar(callback:haxe.Constraints.Function):atom.Disposable;
	function onDidChangeGrammar(callback:haxe.Constraints.Function):atom.Disposable;
	function onDidChangeModified(callback:haxe.Constraints.Function):atom.Disposable;
	function onDidConflict(callback:haxe.Constraints.Function):atom.Disposable;
	function onWillInsertText(callback:haxe.Constraints.Function):atom.Disposable;
	function onDidInsertText(callback:haxe.Constraints.Function):atom.Disposable;
	function onDidSave(callback:haxe.Constraints.Function):atom.Disposable;
	function onDidDestroy(callback:haxe.Constraints.Function):atom.Disposable;
	function observeCursors(callback:haxe.Constraints.Function):atom.Disposable;
	function onDidAddCursor(callback:haxe.Constraints.Function):atom.Disposable;
	function onDidRemoveCursor(callback:haxe.Constraints.Function):atom.Disposable;
	function observeSelections(callback:haxe.Constraints.Function):atom.Disposable;
	function onDidAddSelection(callback:haxe.Constraints.Function):atom.Disposable;
	function onDidRemoveSelection(callback:haxe.Constraints.Function):atom.Disposable;
	function observeDecorations(callback:haxe.Constraints.Function):atom.Disposable;
	function onDidAddDecoration(callback:haxe.Constraints.Function):atom.Disposable;
	function onDidRemoveDecoration(callback:haxe.Constraints.Function):atom.Disposable;
	function onDidChangePlaceholderText(callback:haxe.Constraints.Function):atom.Disposable;
	function getTitle():String;
	function getLongTitle():String;
	function getPath():String;
	function getEncoding():String;
	function setEncoding(encoding:String):Void;
	function isModified():Bool;
	function isEmpty():Bool;
	function save():Void;
	function saveAs(filePath:String):Void;
	function getText():String;
	function getTextInBufferRange(range:atom.Range):String;
	function getLineCount():Float;
	function getScreenLineCount():Float;
	function getLastBufferRow():Float;
	function getLastScreenRow():Float;
	function lineTextForBufferRow(bufferRow:Float):String;
	function lineTextForScreenRow(screenRow:Float):String;
	function getCurrentParagraphBufferRange():atom.Range;
	function setText():Void;
	function setTextInBufferRange(range:atom.Range, text:String, options:Dynamic<Dynamic>):atom.Range;
	function insertText(text:String, options:Dynamic):haxe.extern.EitherType<atom.Range, Bool>;
	function insertNewline():Void;
	function delete():Void;
	function backspace():Void;
	function mutateSelectedText(fn:haxe.Constraints.Function):Void;
	function transpose():Void;
	function upperCase():Void;
	function lowerCase():Void;
	function toggleLineCommentsInSelection():Void;
	function insertNewlineBelow():Void;
	function insertNewlineAbove():Void;
	function deleteToBeginningOfWord():Void;
	function deleteToBeginningOfLine():Void;
	function deleteToEndOfLine():Void;
	function deleteToEndOfWord():Void;
	function deleteLine():Void;
	function undo():Void;
	function redo():Void;
	function transact(groupingInterval:Float, fn:haxe.Constraints.Function):Void;
	function abortTransaction():Void;
	function createCheckpoint():Dynamic;
	function revertToCheckpoint():Bool;
	function groupChangesSinceCheckpoint():Bool;
	function screenPositionForBufferPosition(bufferPosition:atom.Point, options:Dynamic):atom.Point;
	function bufferPositionForScreenPosition(bufferPosition:atom.Point, options:Dynamic):atom.Point;
	function screenRangeForBufferRange(bufferRange:atom.Range):atom.Range;
	function bufferRangeForScreenRange(screenRange:atom.Range):atom.Range;
	function clipBufferPosition(bufferPosition:atom.Point):atom.Point;
	function clipBufferRange(range:atom.Range):atom.Range;
	function clipScreenPosition(screenPosition:atom.Point, options:Dynamic<Dynamic>):atom.Point;
	function decorateMarker(marker:atom.Marker, decorationParams:Dynamic<Dynamic>):atom.Decoration;
	function decorationsForScreenRowRange(startScreenRow:Float, endScreenRow:Float):Dynamic;
	function getDecorations(propertyFilter:Dynamic<Dynamic>):Array<Dynamic>;
	function getLineDecorations(propertyFilter:Dynamic<Dynamic>):Array<Dynamic>;
	function getLineNumberDecorations(propertyFilter:Dynamic<Dynamic>):Array<Dynamic>;
	function getHighlightDecorations(propertyFilter:Dynamic<Dynamic>):Array<Dynamic>;
	function getOverlayDecorations(propertyFilter:Dynamic<Dynamic>):Array<Dynamic>;
	function markBufferRange(range:atom.Range, properties:Dynamic):atom.Marker;
	function markScreenRange(range:atom.Range, properties:Dynamic):atom.Marker;
	function markBufferPosition(position:atom.Point, options:Dynamic):atom.Marker;
	function markScreenPosition(position:atom.Point, options:Dynamic):atom.Marker;
	function findMarkers(properties:Dynamic<Dynamic>):Void;
	function getMarker(id:Float):Void;
	function getMarkers():Void;
	function getMarkerCount():Float;
	function getCursorBufferPosition():atom.Point;
	function getCursorBufferPositions():Array<Dynamic>;
	function setCursorBufferPosition(position:atom.Point, options:Dynamic<Dynamic>):Void;
	function getCursorScreenPosition():atom.Point;
	function getCursorScreenPositions():Array<Dynamic>;
	function setCursorScreenPosition(position:atom.Point, options:Dynamic<Dynamic>):Void;
	function addCursorAtBufferPosition(bufferPosition:atom.Point):atom.Cursor;
	function addCursorAtScreenPosition(screenPosition:atom.Point):atom.Cursor;
	function hasMultipleCursors():Bool;
	function moveUp(lineCount:Float):Void;
	function moveDown(lineCount:Float):Void;
	function moveLeft(columnCount:Float):Void;
	function moveRight(columnCount:Float):Void;
	function moveToBeginningOfLine():Void;
	function moveToBeginningOfScreenLine():Void;
	function moveToFirstCharacterOfLine():Void;
	function moveToEndOfLine():Void;
	function moveToEndOfScreenLine():Void;
	function moveToBeginningOfWord():Void;
	function moveToEndOfWord():Void;
	function moveToTop():Void;
	function moveToBottom():Void;
	function moveToBeginningOfNextWord():Void;
	function moveToPreviousWordBoundary():Void;
	function moveToNextWordBoundary():Void;
	function moveToBeginningOfNextParagraph():Void;
	function moveToBeginningOfPreviousParagraph():Void;
	function getLastCursor():atom.Cursor;
	function getWordUnderCursor(options:Dynamic):Dynamic;
	function getCursors():Void;
	function getCursorsOrderedByBufferPosition():Array<Dynamic>;
	function getSelectedText():String;
	function getSelectedBufferRange():atom.Range;
	function getSelectedBufferRanges():Array<Dynamic>;
	function setSelectedBufferRange(bufferRange:atom.Range, options:Dynamic<Dynamic>):Void;
	function setSelectedBufferRanges(bufferRanges:Array<Dynamic>, options:Dynamic<Dynamic>):Void;
	function getSelectedScreenRange():atom.Range;
	function getSelectedScreenRanges():Array<Dynamic>;
	function setSelectedScreenRange(screenRange:atom.Range, options:Dynamic<Dynamic>):Void;
	function setSelectedScreenRanges(screenRanges:Array<Dynamic>, options:Dynamic<Dynamic>):Void;
	function addSelectionForBufferRange(bufferRange:atom.Range, options:Dynamic<Dynamic>):atom.Selection;
	function addSelectionForScreenRange(screenRange:atom.Range, options:Dynamic<Dynamic>):atom.Selection;
	function selectToBufferPosition(position:atom.Point):Void;
	function selectToScreenPosition(position:atom.Point):Void;
	function selectUp(rowCount:Float):Void;
	function selectDown(rowCount:Float):Void;
	function selectLeft(columnCount:Float):Void;
	function selectRight(columnCount:Float):Void;
	function selectToTop():Void;
	function selectToBottom():Void;
	function selectAll():Void;
	function selectToBeginningOfLine():Void;
	function selectToFirstCharacterOfLine():Void;
	function selectToEndOfLine():Void;
	function selectToBeginningOfWord():Void;
	function selectToEndOfWord():Void;
	function selectLinesContainingCursors():Void;
	function selectWordsContainingCursors():Void;
	function selectToPreviousWordBoundary():Void;
	function selectToNextWordBoundary():Void;
	function selectToBeginningOfNextWord():Void;
	function selectToBeginningOfNextParagraph():Void;
	function selectToBeginningOfPreviousParagraph():Void;
	function selectMarker(marker:atom.Marker):atom.Range;
	function getLastSelection():atom.Selection;
	function getSelections():Array<Dynamic>;
	function getSelectionsOrderedByBufferPosition():Array<Dynamic>;
	function selectionIntersectsBufferRange(bufferRange:atom.Range):Bool;
	function scan(regex:js.RegExp, iterator:haxe.Constraints.Function):Void;
	function scanInBufferRange(regex:js.RegExp, range:atom.Range, iterator:haxe.Constraints.Function):Void;
	function backwardsScanInBufferRange(regex:js.RegExp, range:atom.Range, iterator:haxe.Constraints.Function):Void;
	function getSoftTabs():Bool;
	function setSoftTabs(softTabs:Bool):Void;
	function toggleSoftTabs():Void;
	function getTabLength():Float;
	function setTabLength(tabLength:Float):Void;
	function usesSoftTabs():Dynamic;
	function getTabText():String;
	function isSoftWrapped():Bool;
	function setSoftWrapped(softWrapped:Bool):Bool;
	function toggleSoftWrapped():Bool;
	function getSoftWrapColumn():Void;
	function indentationForBufferRow():Float;
	function setIndentationForBufferRow(bufferRow:Float, newLevel:Float, options:Dynamic<Dynamic>):Void;
	function indentSelectedRows():Void;
	function outdentSelectedRows():Void;
	function indentLevelForLine():haxe.extern.EitherType<String, Float>;
	function autoIndentSelectedRows():Void;
	function getGrammar():Void;
	function setGrammar(grammar:atom.Grammar):Void;
	function getRootScopeDescriptor():atom.ScopeDescriptor;
	function scopeDescriptorForBufferPosition(bufferPosition:atom.Point):atom.ScopeDescriptor;
	function bufferRangeForScopeAtCursor(scopeSelector:String):atom.Range;
	function isBufferRowCommented():Void;
	function copySelectedText():Void;
	function cutSelectedText():Void;
	function pasteText(options:Dynamic):Void;
	function cutToEndOfLine():Void;
	function foldCurrentRow():Void;
	function unfoldCurrentRow():Void;
	function foldBufferRow(bufferRow:Float):Void;
	function unfoldBufferRow(bufferRow:Float):Void;
	function foldSelectedLines():Void;
	function foldAll():Void;
	function unfoldAll():Void;
	function foldAllAtIndentLevel(level:Float):Void;
	function isFoldableAtBufferRow(bufferRow:Float):Bool;
	function isFoldableAtScreenRow(bufferRow:Float):Bool;
	function toggleFoldAtBufferRow():Void;
	function isFoldedAtCursorRow():Bool;
	function isFoldedAtBufferRow(bufferRow:Float):Bool;
	function isFoldedAtScreenRow(screenRow:Float):Bool;
	function scrollToCursorPosition(options:Dynamic<Dynamic>):Void;
	function scrollToBufferPosition(bufferPosition:Dynamic<Dynamic>, options:Dynamic<Dynamic>):Void;
	function scrollToScreenPosition(screenPosition:Dynamic<Dynamic>, options:Dynamic<Dynamic>):Void;
	function scrollToTop():Void;
	function scrollToBottom():Void;
	function getPlaceholderText():String;
	function setPlaceholderText(placeholderText:String):Void;
}
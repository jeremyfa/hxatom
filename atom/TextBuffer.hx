package atom;
@:native("TextBuffer") extern class TextBuffer {
	function new(params:Dynamic<Dynamic>):Void;
	function onDidChange(callback:haxe.Constraints.Function):atom.Disposable;
	function onDidStopChanging(callback:haxe.Constraints.Function):atom.Disposable;
	function onDidConflict(callback:haxe.Constraints.Function):atom.Disposable;
	function onDidChangeModified(callback:haxe.Constraints.Function):atom.Disposable;
	function onDidUpdateMarkers(callback:haxe.Constraints.Function):atom.Disposable;
	function onDidCreateMarker(callback:haxe.Constraints.Function):atom.Disposable;
	function onDidChangePath(callback:haxe.Constraints.Function):atom.Disposable;
	function onDidChangeEncoding(callback:haxe.Constraints.Function):atom.Disposable;
	function onWillSave(callback:haxe.Constraints.Function):atom.Disposable;
	function onDidSave(callback:haxe.Constraints.Function):atom.Disposable;
	function onWillReload(callback:haxe.Constraints.Function):atom.Disposable;
	function onDidReload(callback:haxe.Constraints.Function):atom.Disposable;
	function onDidDestroy(callback:haxe.Constraints.Function):atom.Disposable;
	function onWillThrowWatchError(callback:haxe.Constraints.Function):atom.Disposable;
	function getStoppedChangingDelay():Float;
	function isModified():Bool;
	function isInConflict():Bool;
	function getPath():String;
	function setPath(filePath:String):Void;
	function setEncoding(encoding:String):Void;
	function getEncoding():String;
	function getUri():String;
	function isEmpty():Bool;
	function getText():String;
	function getTextInRange(range:atom.Range):String;
	function getLines():Array<Dynamic>;
	function getLastLine():String;
	function lineForRow(row:Float):String;
	function lineEndingForRow(row:Float):String;
	function lineLengthForRow(row:Float):Float;
	function isRowBlank(row:Float):Bool;
	function previousNonBlankRow(startRow:Float):Float;
	function nextNonBlankRow(startRow:Float):Float;
	function setText(text:String):atom.Range;
	function setTextViaDiff(text:String):Void;
	function setTextInRange(range:atom.Range, text:String, options:Dynamic<Dynamic>):atom.Range;
	function insert(position:atom.Point, text:String, options:Dynamic<Dynamic>):atom.Range;
	function append(text:String, options:Dynamic<Dynamic>):atom.Range;
	function delete(range:atom.Range):atom.Range;
	function deleteRow(row:Float):atom.Range;
	function deleteRows(startRow:Float, endRow:Float):atom.Range;
	function markRange(range:atom.Range, properties:Dynamic):atom.Marker;
	function markPosition(position:atom.Point, properties:Dynamic):atom.Marker;
	function getMarkers():Array<Dynamic>;
	function getMarker(id:Float):atom.Marker;
	function findMarkers(params:Dynamic):Array<Dynamic>;
	function getMarkerCount():Float;
	function undo():Void;
	function redo():Void;
	function transact(groupingInterval:Float, fn:haxe.Constraints.Function):Void;
	function clearUndoStack():Void;
	function createCheckpoint():Dynamic;
	function revertToCheckpoint():Bool;
	function groupChangesSinceCheckpoint():Bool;
	function scan(regex:js.RegExp, iterator:haxe.Constraints.Function):Void;
	function backwardsScan(regex:js.RegExp, iterator:haxe.Constraints.Function):Void;
	function scanInRange(regex:js.RegExp, range:atom.Range, iterator:haxe.Constraints.Function):Void;
	function backwardsScanInRange(regex:js.RegExp, range:atom.Range, iterator:haxe.Constraints.Function):Void;
	function replace(regex:js.RegExp, replacementText:String):Float;
	function getRange():atom.Range;
	function getLineCount():Float;
	function getLastRow():Float;
	function getFirstPosition():atom.Point;
	function getEndPosition():atom.Point;
	function getMaxCharacterIndex():Float;
	function rangeForRow(row:Float, includeNewline:Bool):atom.Range;
	function characterIndexForPosition(position:atom.Point):Float;
	function positionForCharacterIndex(offset:Float):atom.Point;
	function clipRange(range:atom.Range):atom.Range;
	function clipPosition(position:atom.Point):atom.Point;
	function save():Void;
	function saveAs(filePath:Dynamic):Void;
	function reload():Void;
}
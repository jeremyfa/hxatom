package atom;

@:realPath("atom.TextBuffer") @:native("TextBuffer") extern class TextBuffer {
	function new(params : Dynamic<Dynamic>) : Void;
	function append(text : String, options : Dynamic<Dynamic>) : Range;
	function backwardsScan(regex : js.RegExp, iterator : haxe.Function) : Void;
	function backwardsScanInRange(regex : js.RegExp, range : Range, iterator : haxe.Function) : Void;
	function characterIndexForPosition(position : Point) : Float;
	function clearUndoStack() : Void;
	function clipPosition(position : Point) : Point;
	function clipRange(range : Range) : Range;
	function createCheckpoint() : Dynamic;
	function delete(range : Range) : Range;
	function deleteRow(row : Float) : Range;
	function deleteRows(startRow : Float, endRow : Float) : Range;
	function findMarkers(params : Dynamic) : Array<Dynamic>;
	function getEncoding() : String;
	function getEndPosition() : Point;
	function getFirstPosition() : Point;
	function getLastLine() : String;
	function getLastRow() : Float;
	function getLineCount() : Float;
	function getLines() : Array<Dynamic>;
	function getMarker(id : Float) : Marker;
	function getMarkerCount() : Float;
	function getMarkers() : Array<Dynamic>;
	function getMaxCharacterIndex() : Float;
	function getPath() : String;
	function getRange() : Range;
	function getStoppedChangingDelay() : Float;
	function getText() : String;
	function getTextInRange(range : Range) : String;
	function getUri() : String;
	function groupChangesSinceCheckpoint() : Bool;
	function insert(position : Point, text : String, options : Dynamic<Dynamic>) : Range;
	function isEmpty() : Bool;
	function isInConflict() : Bool;
	function isModified() : Bool;
	function isRowBlank(row : Float) : Bool;
	function lineEndingForRow(row : Float) : String;
	function lineForRow(row : Float) : String;
	function lineLengthForRow(row : Float) : Float;
	function markPosition(position : Point, properties : Dynamic) : Marker;
	function markRange(range : Range, properties : Dynamic) : Marker;
	function nextNonBlankRow(startRow : Float) : Float;
	function onDidChange(callback : haxe.Function) : Disposable;
	function onDidChangeEncoding(callback : haxe.Function) : Disposable;
	function onDidChangeModified(callback : haxe.Function) : Disposable;
	function onDidChangePath(callback : haxe.Function) : Disposable;
	function onDidConflict(callback : haxe.Function) : Disposable;
	function onDidCreateMarker(callback : haxe.Function) : Disposable;
	function onDidDestroy(callback : haxe.Function) : Disposable;
	function onDidReload(callback : haxe.Function) : Disposable;
	function onDidSave(callback : haxe.Function) : Disposable;
	function onDidStopChanging(callback : haxe.Function) : Disposable;
	function onDidUpdateMarkers(callback : haxe.Function) : Disposable;
	function onWillReload(callback : haxe.Function) : Disposable;
	function onWillSave(callback : haxe.Function) : Disposable;
	function onWillThrowWatchError(callback : haxe.Function) : Disposable;
	function positionForCharacterIndex(offset : Float) : Point;
	function previousNonBlankRow(startRow : Float) : Float;
	function rangeForRow(row : Float, includeNewline : Bool) : Range;
	function redo() : Void;
	function reload() : Void;
	function replace(regex : js.RegExp, replacementText : String) : Float;
	function revertToCheckpoint() : Bool;
	function save() : Void;
	function saveAs(filePath : Dynamic) : Void;
	function scan(regex : js.RegExp, iterator : haxe.Function) : Void;
	function scanInRange(regex : js.RegExp, range : Range, iterator : haxe.Function) : Void;
	function setEncoding(encoding : String) : Void;
	function setPath(filePath : String) : Void;
	function setText(text : String) : Range;
	function setTextInRange(range : Range, text : String, options : Dynamic<Dynamic>) : Range;
	function setTextViaDiff(text : String) : Void;
	function transact(groupingInterval : Float, fn : haxe.Function) : Void;
	function undo() : Void;
}
